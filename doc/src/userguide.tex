\documentclass{article}

\input{macro}

\title{\texttt{theia} \\ \quad \\A 3D Gaussian beam tracer \\ \quad \\ \begin{small} Version 0.1.0 \end{small} \\ \quad \\ \textit{User Guide}}

\author{Rapha\"el Duque}

\begin{document}

\maketitle

\begin{abstract}
theia is a command line program and Python library for 3D Gaussian beam tracing. It supports many different types of optical components, general 3D placing and orientation of these components and general astigmatic Gaussian beams, among other features. theia was developed at the Optics Group of the Virgo gravitational observatory in Cascina, Italy. For more information on the theia project, surf to \tt{http://37.117.61.221:56000}.

This document is a user's guide to the \texttt{theia} command line tool. It gives the information concerning the installation instructions, the usage and the input and output of \texttt{theia} necessary to operate the program from the command line. It also provides a short introduction to the theia library API. For more details on the \texttt{theia} Python library, please refer to the API Guide provided along with this User Guide, or go to \tt{http://37.117.61.221:56000/docs/html/index.html} for the online API guide.
\end{abstract}


\tableofcontents
\newpage


\section{\texttt{theia} Quick Start}
For a quick start of theia once you are in the project repository, install theia locally with \texttt{make install}. The command \tt{theia} will then be available to you everywhere and  you can run the tutorial input files (with extension \texttt{.tia}) found in the \tt{tutos/} folder with \texttt{theia FNAME.tia}, replacing \texttt{FNAME.tia} by one of the tutorial files.

The input \tt{.tia} files provide (among other things) the optical setup information in text form. The output \tt{.out} file reports the physical data (waist position relatively to the origin of the beam and waist size) of the beams generated by the propagation of the input beam.

The \tt{alloptics.tia} tutorial file is particularly fit to quickly learn the input format because all the possible types of optics are used in the corresponding simulation. 

\section{Description of theia}
In the section, we will briefly explain the ideas behind the development of theia, describe the way theia sees the physical objects it deals with and tracing algorithm it implements.

\subsection{The theia rationale}
theia has been designed for flexible and practical operation. This why theia is not only a command line tool, but also a Python library aiming at scripting and written accordingly -- please see the theia API Guide for more details on this library. 

The theia command line tool has it its own right been designed with flexibility and pragmatism in mind. The theia input and output files were thought to allow high level features to insure ease of writing and reading by humans, to be printed out, brought to the optical bench and used as references to follow the evolution of the optical layout and its components, to be read as structured files containing figures one can readily compare to experimental data, etc.

Aiming for flexibility also implies liberty for the user when it comes to input. The theia user can specify as much information as she or he wishes. From specifying zero parameters and using default values for all the arguments to using built-in values such as handy units, users have a large radius of action for their input.

With liberty must also come caution. If the user specifies geometrically inconsistent parameters -- leading to self-intersecting surfaces for instance --, then warnings may be issued to standard output (unless specific command line flags are used, see 3.2) but the simulation will carry on almost unseemingly, and may lead to unexpected behavior. 

\subsection{The operation of theia}
theia is a command line 3D Gaussian beam tracing program. During its operation, input beams and an optical setup are read from an input text file and these beams are traced and interact with optical components. Following the rules of geometrical and Gaussian optics, and according to some selection rules designed to insure the termination of the program, this process produces new beams, by reflection and transmission of the former beams on the surfaces of the optical components. This creation and selection process is repeated recursively in order to calculate all the beams produced by the input beams and their geometrical and Gaussian characteristics. 


\subsection{Beams and optics}
\subsection{Algorithm and approximations}

\section{Installation and usage}
\subsection{Installation instructions}
theia uses the Python standard library component \tt{setuptools} to install the command line tool theia as well as the Python library. 

\paragraph{Local installation.}To install theia to your local environment, \tt{cd} to the project repository root and issue the following commands:

\begin{itemize}
\item \tt{make install} to install the theia command line program and library and compile the documentation in the \tt{doc/} sub-directory of the project;
\item \tt{make build-theia} to only install the program and the library but not compile the documentation (useful if you do not have a latex environment running);
\item \tt{make build-doc} to only compile the documentation (useful if you have modified the library to your liking -- please do).
\end{itemize}

\warn{This procedure will install the theia script to \tt{\$HOME/.local/bin}, and this directory \textbf{must} be in your \tt{PATH} in order to have access to theia from anywhere in your file system.}

\paragraph{System-wide installation.}For a system-wide installation, you can issue \tt{python setup.py install} with root privileges from the project root repository. The documentation must be compiled separately as indicated in the former paragraph and moved to some shared directory if you like.

\paragraph{Uninstalling.} Uninstalling a local installation if fairly simple: issue \tt{make clear} from the project root directory. This will wipe your \tt{\$HOME/.local} of anything that has to do with theia. All the documentation, tutorial files or theia input or output files elsewhere will of course stay in place after this procedure.

Uninstalling a system-wide installation is more tricky, and we do not provide an automated procedure for this and admins probably know better than us on this subject, though on most systems \tt{setuptools} puts library files in \tt{/usr/local/lib/python2.7/*-packages} and scripts in \tt{/usr/local/bin}.

\subsection{Usage on the command line}
The general usage of theia is: \tt{theia [options] FNAME}, where:

\begin{itemize}
\item \tt{[options]} are command line options. See the next paragraph or the output of \tt{theia -h} for more details;
\item \tt{FNAME} is the name of the configuration file to use for the simulation, with or without the \tt{.tia} extension. See the next section for details on the format of the \tt{.tia} file.
\end{itemize}

\paragraph{Command line options.}As introduced in section 2. of this User Guide, theia takes one configuration file as an input and may write out to output files and to standard output (the terminal window). The command line options allow the user to control all these outputs. The command line options are summed up in table \ref{option}.


\begin{table}[h]
\begin{center}
\begin{tabular}{| p{4cm} | p{10cm} |}
\hline
\textbf{Command line option} & \textbf{Effect} \\
\hline \hline
\tt{-h, --help} & show the usage and the command line options of theia and exit with a success exit code\\
\hline
\tt{-i, --info} & during the simulation, do not output tracing information to standard output (see section 4.3 for details on the information that is output)\\
\hline
\tt{-w, --no-warn} & during the simulation, do not output warnings to standard output (see section 4.3 to find out what warnings may be written)\\
\hline
\tt{-t, --no-text} & after the simulation, do not write the \tt{.out} text output file (see section 4.2 for details)\\
\hline
\tt{-c, --no-CAD} & after the simulation, do not write the CAD file\\
\hline
\end{tabular}
\end{center}
\caption{Command lines options of theia.}
\label{option}
\end{table}

\section{Input and output to theia}
\subsection{The \tt{.tia} input format}
\tt{.tia} format input files are simple text files reporting the simulation parameters and the optical setup to the theia CLI tool. In such a file, each line is used to describe its own object\footnote{By the way, all spaces and tabs are ignored, so you can throw some in wherever you want.}. These objects can be simulation parameters, simulation meta-data or optical components. The object you are specifying with a given line depends on the format of the line, according to the following table \ref{inputformat}.

\begin{table}[h]
\begin{center}
\begin{tabular}{|p{3cm}|p{4cm}|p{8cm}|}
\hline
\textbf{Lines starting with ...} & \textbf{... specify ...} & \textbf{... and the rest of the line is ...} \\ \hline \hline

\tt{\#} & a comment & ignored \\ \hline

\tt{order=} & the order of the simulation & a Python expression evaluating to an integer \\ \hline
\tt{threshold=} & the threshold of the simulation & a Python expression evaluating to a floating point number  \\ \hline

\tt{bm} & an input orthogonal Gaussian beam & a comma-separated list of \textit{entries}  (see following paragraph) specifying the characteristics of the beam \\ \hline
\tt{mr} & a mirror object & a comma-separated list of \textit{entries} specifying the characteristics of the mirror \\ \hline
\tt{th} & a thinlens object & a comma-separated list of \textit{entries} specifying the characteristics of the thin lens \\ \hline
\tt{tk} & a thicklens object & a comma-separated list of \textit{entries} specifying the characteristics of the thick lens \\ \hline
\tt{bd} & a beamdump object & a comma-separated list of \textit{entries} specifying the characteristics of the beamdump \\ \hline

anything else & the long name of the simulation (appears in the output file) & any text input \\ \hline



\end{tabular}
\end{center}
\caption{Format of each type of line in a \tt{.tia} input file}
\label{inputformat}
\end{table}

For beams, mirrors, beamdumps, thin and thick lenses, report to the Quick Reference document in order to know what are the order and the signification of the entries.

\paragraph{Entries and available Python expressions.}An entry in a input file line is of the form (remember spaces and tabs are not taken into account) \tt{VAR=EXPRESSION} or simply \tt{EXPRESSION}. Use the second form when you have specified all the parameters since the beginning of the line and in the right order, and the first form when you want to input in the order you like, or you have omitted some parameters (think of this as a set of argument to a function, the arguments are considered in the right order and complete until the first \tt{VAR=EXPRESSION}, and then its up to you to specify or not the following parameters). 

\tt{EXPRESSION} is any Python expression that is valid \textit{in the scope where the input reading function is defined}. What this means is that you can use:
\begin{itemize}
\item Standard Python literal integers, floats and operators: \tt{4.}, \tt{.2e-3 * 3 / 2}, etc.
\item The functions and constants that are available as built-ins in this scope (these are listed in the Quick Reference document): \tt{arccos(3 * exp(-2.)) * mW}, \tt{sqrt(4.*mm*mm)}, \tt{arctan(pi/12)}, etc.
\item Any user defined function or constant as long as it is declared as a global in the \tt{theia.helpers.settings} module and initialized correctly (see section 5.1 on globals), declared in the \tt{theia.helpers.units} module, or declared directly in \tt{theia.running.parser}. After all of these operations, theia has to be rebuilt with \tt{make install}.
\end{itemize}




\warn{As we just mentioned, the parts of an entry line which are between two commas or between a comma and a \tt{=} sign are evaluated as Python expressions, which allows for a great flexibility of the input. \textit{Nonetheless}, you must beware of Python expressions evaluation which might lead to unexpected behavior, particularly on integers! For example, if one enters \tt{(3/4)*pi}, the evaluation will lead to 0 because of integer division, and not $3\pi/4 = 135\degree$. To obtain $135\degree$, one should enter \tt{3*pi/4}, or \tt{(3./4)*pi} for instance.}



\paragraph{Empty constructors.}In theia, all the constructors available to the user have a complete set of default values (see section 5.2 for details on this). Thus an input file can very well contain a line with a tag and \textit{zero} arguments, such as: 

\tt{\#example usage of a empty constructor for a (thus default) input beam}

\tt{bm}


To find out what the default values of all the constructors are, report to the Quick Reference document.


\paragraph{Meta data-specifying lines overwrite each other.} Lines used to specify the simulation order, threshold and long name overwrite each other. If you specify a "\tt{threshold=}" line after another "\tt{threshold=}" line, this latter one will overwrite the value specified in the former line. The same mechanics apply to "\tt{order=}" and long-name lines.

\subsection{The \tt{.out} output file}
The output file is also a simple text file. In contains formatted information on the simulation, the optics present in the setup ad the beams generated by these. All this information is divided in sections:

\begin{itemize}
\item The \tt{META DATA} section specifies the date at which the file was written, the input file used, the various simulation parameters.

\item The \tt{SIMULATION DATA} section gives information on the components used in the simulation (component type, reference and position of the HR surface chord center), and on the generated beam trees (a reference to their original beam and the number of beams the tree contains in total).

\item The \tt{BEAM LISTING} section reports, in a beam tree by beam tree fashion, the beams  contained in the different beam trees. for each beam, you will find the optic and face the beam departs from, the length of the beam, the optic and face the beam finishes on, the reference to the beam, and then the waist positions (along the beam starting from the beam origin), waist sizes and finally beam direction. The waists are given in the proper basis attached to the beam, as described in section 2.3.
\end{itemize}

\paragraph{Beam references.}The reference of each beam (as it appears at the end of each entry in the \tt{BEAM LISTING} section of the output file) is the reference of its parents beam plus a tag which can be \tt{r} or \tt{t} according to whether the beam was produced by reflexion or transmission of the parent beam. The references of the input beams are read in the input file.


Here is a sample of output:

\tt{(M1, AR) 0.946496969941m (L1, HR) TBttt \{}

	\quad	\tt{Waist Pos: (-1.8387309993210437, -1.8387309993210468)m}
	
	\quad	\tt{Waist Size: (0.00016310752802, 8.15537640098e-05)mm}
	
	\quad	\tt{Direction: (90.0, 4.68099236149e-13)deg}
	
	\tt{\}}
	
This sample describes a beam travelling 94.6~cm from the AR surface of the optic labeled M1 (surely a mirror) to the HR surface of the optic labeled L1 (surely a lens). This beam is the beam transmitted by the beam transmitted by the beam transmitted by the input beam labeled \tt{TB}. It waists are about .1~$\mu$m and both located 1.83~m behind the origin of the beam (thus this beam is in its diverging phase all the way from M1 to L1). Its direction is along the positive $X$ axis.

\newpage
\section{An introduction to the theia API}

This section is an introduction to the Application Programmers Interface to the theia library. It give somewhat more detail on the algorithm and data structures of theia and how they are implemented in theia. This guide may be useful to anyone who wants to use theia to develop their own optical simulation scripts, and to anyone who would like to contribute to theia. For a through and complete treatment of the theia API, see the API Guide document or the online documentation.

Throughout this section, Unix \tt{paths/like/this} are understood as relative to the theia project root directory (\textit{e.g.} \tt{doc/img/flow.png}) and Python import statements \tt{like.this.one} are understood as relative to the theia package (\textit{e.g.} \tt{running.simulation.Simulation.\_\_init\_\_}).


\subsection{A note on global variables}
The theia CLI tool uses a certain number of global variables in order to keep values which don't change along the execution. These global variables are consequently needed by a certain number of functions defined in the library in order for the CLI tool to be as functional as possible. When using theia as a library, one may not need all these globals and they may even get in the way of development.

\paragraph{How to take care of the globals once and for all.}The global variables are \textit{all} declared in \tt{helpers.settings} and are initialized with \tt{helpers.settings.init} at the very beginning of \tt{main.main}, which takes in a dictionary and reads the globals from there. If you don't want to hear about the globals, you can place the following snippet (found in \tt{tests/test\_simulation.py}) at the beginning of your script and not worry about the globals.

\begin{lstlisting}
# use this snippet and all globals worries are gone
from theia.helpers.settings import init

# initialize globals in a dictionary
dic = {'info': False, 'warning': False, 'text': False, 'cad': False,
		'fname': 'test_optics'}

init(dic)

# you're all set 
\end{lstlisting}

\paragraph{Who uses the globals?}Here is a table (table \ref{globals}) listing the global variables and which functions use them.

\begin{table}[h]
\begin{center}

\begin{tabular}{|c | l |}
\hline
\textbf{Global} & \textbf{Used by} \\ \hline \hline

\tt{info} & \tt{optics.beamdump.BeamDump.hit} \\
& \tt{optics.lens.Lens.hitActive} \\
& \tt{optics.mirror.Mirror.hitHR} \\
& \tt{optics.mirror.Mirror.hitAR} \\
& \tt{optics.optic.Optic.hitSide} \\
& \tt{tree.beamtree.treeOfBeam} \\ \hline

\tt{warning} & \tt{optic.mirror.Mirror.\_\_init\_\_} \\
& \tt{optic.thicklens.ThickLens.\_\_init\_\_} \\
& \tt{optic.thinlens.ThinLens.\_\_init\_\_} \\
& \tt{running.simulation.Simulation.run} \\ \hline

\tt{text, cad, fname} & \tt{main.main} \\ \hline

\end{tabular}
\caption{The global variables of theia and the functions who use them}
\label{globals}
\end{center}
\end{table}
\subsection{Classes and inheritance hierarchy}
Figure \ref{inheritancehierarchy} presents the inheritance hierarchy of the classes of theia. If you see a method twice, it just means the daughter class reimplements the method. You'll also find the signature of the methods and  initializers.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=.8]{inheritancehierarchy}
\caption{Inheritence hierarchy of theia}
\label{inheritancehierarchy}
\end{center}
\end{figure}
\paragraph{A word on initializer default values.}We try to avoid surprises and stay consistent throughout the code with the following policies concerning classes at the leaves of the inheritance graph:

\begin{enumerate}
\item For classes whose initializers will be called only with input form users (read from an input file or in a a script), \textit{every} parameter of the constructor has a default value and the constructor can be called \textit{without arguments}. What's more, the input of the user is processed through the class initializer and then fed to the initializer of the mother class. For example, the user may provide \tt{X}, \tt{Y} and \tt{Z} to the constructor she or he calls, then these are processed and it is \tt{[X, Y, Z]} as a list (with types checked etc.) which is fed to the mother initializer. This concerns the constructors for \tt{ThinLens}, \tt{ThickLens}, \tt{Mirror}, \tt{BeamDump}.

\item For classes whose initializers are called solely internally, there are \textit{no default values}. These are the constructors of \tt{SetupComponent}, \tt{Optic}.

\item For classes that may be instantiated internally and by users, the class has a \tt{classmethod} decorated method, whose parameters \textit{all have default values} and which is intended to be used with input from the user, as the constructors described in the previous point 1. This method is named \tt{user\$CLASSNAME} and processes the input of the user into input for the class's proper \tt{\_\_init\_\_} initializer. On the other hand, this proper initializer is intended for internal use only and has \textit{no default values}. This is for example the case of the \tt{optics.beam.GaussianBeam} class, whose constructor is called internally to generate new beams and with user input read from the input file. In this last case it is \tt{userGaussianBeam} which is called.
\end{enumerate}

\paragraph{Abstract Base Classes.}The highest class of the optical classes hierarchy is the \tt{optics.component.SetupComponent} class. Its metaclass is set to \tt{abc.ABCMeta}, making it an abstract base class\footnote{See \tt{docs.python.org/2/library/abc.html} for details}. This essentially means that no daughter class of this class can be instantiated unless all the methods decorated with \tt{abc.abstractmethod} have been reimplemented by the daughter class. The methods concerned with this limitation are \tt{optics.component.SetupComponent.lines} and \tt{optics.component.SetupComponent.isHit}. Methods decorated with \tt{abstractmethod} in an abstract base class can eventually be implemented in the mother class, but in theia they all \tt{pass}, and could be called \textit{pure virtual} for someone coming from C++.

\subsection{Call graph}
Here (figure \ref{callgraph}) is the call graph of the theia CLI tool, from which one can easily deduce the call graph of any individual function. You can refer to the API Guide or the online API documentation to find out in which module the functions are defined.


\begin{figure}[h]
\begin{center}
\includegraphics[scale=.5]{callgraph}
\end{center}
\caption{Call graph of the theia CLI tool. \textit{italics}: generic object or group of methods, \textcolor{green}{green:} recursive call, \textcolor{red}{red:} handled exception.}
\label{callgraph}
\end{figure}



\paragraph{Note on the  call stack.}According to this call graph (figure \ref{callgraph}), the stack has a maximum height of $9~+~2(n-1)$ when there are $n$ levels of recursion. Generally, the program crashes -- if it crashes -- by recursion depth limit exceeding (leading to a handled \tt{RunTimeError} exception and an exit with an error code of 1) before causing a stack overflow.

\subsection{Miscellaneous remarks}

\paragraph{Coding style.}In the development of theia we have tried to stick to a couple of coding style conventions, which may help to review the code and are important to know for anyone wishing to contribute.

\begin{itemize}
\item The code of theia is heavily commented and doc-stringed, and it should stay that way in order for theia to be an accessible library.

\item Throughout the library, classes and attributes look \tt{LikeThis} whereas objects and methods look \tt{likeThis}.

\item There is an approximate (it isn't true only in the \tt{helpers} sub-package) \textit{one file} $\rightarrow$ \textit{one class} correspondence and files are named accordingly with the objects they define. Generally, we have a tendency to distribute functions in different modules if they provide different functionalities, regardless of the total number of modules. Functions are together in a module if they belong together, consequently they are many modules in theia.

\item We tend never to skip more than 1 line (Python is already very formatted).

\item \tt{\# Provides} lines at the very beginning of modules allow to know at a glance what variables, functions and classes the module provides.

\item Imports: import first from the Python standard library and third-party packages, then from theia sub-packages other than the current, then from the current theia sub-package. For theia sub-packages imports, always use the \tt{from ... import} idiom, always use relative imports (\tt{from ..helpers import interaction}) and for standard library and third-parties always \tt{import} before you \tt{from ... import}. We try to not import what we don't need.

\item Class doc-string: present class attributes before instance attributes and mention if they are inherited.
\end{itemize}

\paragraph{Writing to \tt{stdout} and files.}Many classes reimplement the \tt{\_\_str\_\_} method to have \tt{print(object)} print a neatly formated description of the object. To this effect there are two important methods: \tt{lines} (instance method) and \tt{helpers.tools.formatter} (global scope function). \tt{formatter} takes a list of strings (lines to output) and makes C-style indented output with curly braces in the right place in one large string. Basically, one has:

\begin{lstlisting}
# inside class scope
def __str__(self):
	return formatter(self.lines())
	
\end{lstlisting}


\end{document} 
