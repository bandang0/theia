'''Defines the Simulation class for theia.'''

# Provides:
#   class Simulation
#       __init__
#       __str__
#       load
#       run

import numpy as np
from helpers import settings
from helpers.units import *
from helpers.tools import formatter
from optics.beam import GaussianBeam
from optics.beamdump import BeamDump
from optics.thinlens import ThinLens
from optics.thicklens import ThickLens
from optics.mirror import Mirror
from tree import beamtree
from . import parser


class Simulation(object):
    '''

    Simulation class.

    This class is a wrapper for all the metadata (names of setup and of files,
    etc.) as well as for the high level functions of a simulation.

    *=== Attributes ===*
    LName: name of the simulation [string]
    FName: name of the file for outputs (without extension) [string]
    OptList: list of optical components of the setup [list of optics]
    InBeams: list of input beams [list of beams]
    BeamTree: binary tree of beams [Beam Tree from tree package]

    '''

    def __init__(self, FName):
        '''Simulation constructor.

        LName: simulation name. [string]
        Fname: output files name without extension. [string]
        OptList: list of SetupComponents of the setup. [list of SetupComponents]
        InBeams: list of input beams. [list of GaussianBeams]
        BeamTreeList: list of BeamTrees generated by the input beams.
            [list of BeamTrees]
        '''

        self.LName = " Dev Simulation"
        self.FName = FName
        self.OptList = []
        self.InBeams = []
        self.BeamTreeList = []
        self.Order = np.inf
        self.Threshold = -1.*mW


    def __str__(self):
        '''String representation of the simulation, for print(simulation).

        '''
        sList = ["Simulation: " + str(self.LName) + " (" + str(self.FName)\
                 + ".*) {"]
        sList.append("OptList: {")
        for opt in self.OptList:
            sList = sList + opt.lineList()
        sList.append("}")
        sList.append("InBeams: {")
        for beam in self.InBeams:
            sList = sList + beam.lineList()
        sList.append("}")
        sList.append("BeamTrees: {")
        for tree in self.BeamTreeList:
            sList = sList + tree.lineList()
        sList.append("}")
        sList.append("}")

        return formatter(sList)


    def load(self):
        '''Initialize simulation attributes by input from .tia file.

        See documantation for the format of the input file.

        No return value.

        '''
        finalList = parser.readIn(self.FName + '.tia')

        # populate simulation attributes with objects from input
        for uple in finalList:
            if uple[0] == 'LName':
                self.LName = uple[1]
            elif uple[0] == 'order':
                self.Order = uple[1]
            elif uple[0] == 'threshold':
                self.Threshold = uple[1]
            elif uple[0] ==  'bm':
                self.InBeams.append(GaussianBeam(**uple[1]))
            elif uple[0] == 'mr':
                self.OptList.append(Mirror(**uple[1]))
            elif uple[0] == 'th':
                self.OptList.append(ThinLens(**uple[1]))
            elif uple[0] == 'tk':
                self.OptList.append(ThickLens(**uple[1]))
            elif uple[0] == 'bd':
                self.OptList.append(BeamDump(**uple[1]))


    def run(self):
        '''Run simulation with input as read by load.

        threshold: power of beam below which the simulation stops tracing child
                    beams. [float]
        order: maximum order to keep daughter beams. [integer]

        No return value.
        '''
        #warn if threshold is negative or order is inf
        if settings.warning and self.Threshold < 0.:
            print "theia: Warning: Running simulation with negative threshold,"\
            + " termination not guaranteed."

        if settings.warning and self.Order is np.inf:
            print "theia: Warning: Running simulation with infinite order,"\
            + " termination not guaranteed."

        # reinitialize treeList
        self.BeamTreeList = []

        for k in range(len(self.InBeams)):
            self.BeamTreeList.append(beamtree.treeOfBeam(self.InBeams[k],
            self.OptList, self.Order, self.Threshold ))

    def writeOut(self):
        pass

    def writeCAD(self):
        pass
